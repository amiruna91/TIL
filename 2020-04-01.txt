1.프로그램 오류
	- 에러(error) : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
		* 시스템, 운영체제, 자바실행환경 등의 오작동.  <---- 개발자의 영역이 아니다/ 예외처리 대상이 아님

	- 예외(exception) : 프로그램 코드에 의해서 방어할 수 있는 미약한 오류

	1)종류
		- 에러 - 메모리 부족, JVM 오작동, 스택오버플로우 ....

		- 예외 - RuntimeException, IndexOutOfBoundsException, NullPointException....

2.예외 클래스의 계층구조 (상속계층도는 책 p293)
       	- Throwable 클래스
		- 예외와 에러의 부모클래스, 둘 모두 Throwable 클래스를 상속 받아서 만들어진다.
	 	  오류의 정보 및 오류처리를위한 디버깅 정보의 출력, 오류 메서지제공과 같은 기능들이 
		 정의되어 있다.
	- Exception 클래스는 두 그룹으로 나눠질 수 있다.
		1) RuntimeException : 개발자의 코딩 실수로 발생되는 예외. <----- (예외처리 대상이 아님)
		2) 그 외 Exception의 자손들(Excepiton 클래스들 이라고 불른다.)
			: 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외  <---- (예외처리의 대상)

3.예외 처리하기
	정의 : 프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드를 작성하는 것
	목적 : 프로그램의 비정상 종료을 막고, 정상적인 실행상태를 유지하는 것

	- try - catch 문
		try {
		   // 예외발생이 예고된 기능
		} catch (예외클래스명 변수명) {
		   // 예외발생시 실행할 수행문
		}

	* catch () {} 블록을 여러 개 작성해야 하는경우
		 - 예외를 catch하는 순서가 중요한다. 부모 클래스가 아래쪽에 위치하게 작성해야 한다.
		 - 맨 마지막 catch() {} 블록은 Exception 객체를 잡는다.
		 - catch () {} 블록에서 Exception을 지정해두면 예상하지 못한 예외도 해당 catch () {}
		   에서 잡을 수 있기 때문에 프로그램의 갑작스러운 종료를 방지할 수 있다.

	- 예외 위임
		: throws 키워드를 사용하면 해당 메서드안에서 발생이 예상되는 예외에 대한 처리를 이
		  메서드를 호출한 측에 떠넘길 수 있다.
		public static void 메서드명(매개변수) throws 예외클래스명, 예외클래스명 {
			수행문~~
			수행문~~
		}

4.예외처리된 정보 가지고 오기
	-printStackTrace()	<----- 자주 사용!!!
		: 예외발생 당시에 있었던 메서드의 정보와 예외 메세지를 화면에 출력한다.
	-getMessage()
		: 발생한 예외클래스의 저장된 메세지를 얻을 수 있다.

5.강제로 예외 발생시키기
	-throws  <------ 예외처리 위임 (메서드 선언부)
	-throw   <------ 강제로 예외 발생 (수행문)
		 
		예외강제 발생시키기, 예외의 변환
			예외강제 발생 : throw 키워드 다음에 발생시킬 예외객체를 적는다.
			예외의 변환   : 발생된 예외를 가로채고, 다른 예외를 발생시킨다.

6.checked, unchecked예외
	checked Exception :
			RuntimeException의 자손이 아닌 모든 Exception은 CheckedException이다.
			CheckedException은 컴파일러가 예외처리 구현 여부를 반드시 체크한다.
			try ~ catch나 throws를 이용한 예외처리가 반드시 구현되어 있어야 한다.
	unchecked Exception : 
			RuntimeException의 자손은 전부 UncheckedException이다.
			UncheckedException은 컴파일러가 예외처리 구현 여부를 체크하지 않는다.
			로직구현상 필요한 경우 예외처리를 하는 것도 가능하다.

7.사용자 정의 예외
	Exception클래스 또는 RuntimeException클래스로부터 상속받아서 사용저 정의 예외클래스를 만든다.
	하지만 만들때 주로 RuntimeException클래스 상속받아서 만든다.

8.finally블럭
	: finally블럭은 예외의 발생여부에 상관없이 실행되어야할 코드를 포함시킬 목적으로 사용된다.
	  finally에는 들어가는 수행문은 정해져있다. 점유했던 컴퓨터의 리소스를 해제 시키는 수행문과 트랜잭션 처리와 관련된 소스가 들어간다.
	
	try {						try {
	    ①수행문1	// 예외발생 예고		   * 컴퓨터의 리소스(I/O리소스, 네트워크리소스, Database.
	    ②수행문2					    Connection 리소스 등)
	} catch (Exception e) {			 	   
	    ③수행문3					   컴퓨터의 리소스을 점유하는 수행문;	<--  예외발생이 예고된 메서드
	} fianlly {					   점유된 리소스를 활용하는 수행문;	<-- 예외발생이 예고된 메서드
	    ④수행문4					   점유된 리소스를 활용하는 수행문;	<-- 예외발생이 예고된 메서드
	}						   
							   // 부적절, 위의 모든 수행문이 오류없이 실행된 경우에만 실행되기 때문에.
							   // 점유했던 리소스를 해제시키는 수행문;	
							} catch(예외클래스 변수명) {
	* 수행문1이 정상실행 					예외발생시 실행되는 수행문;
	   ① -> ② -> ④
							   // 부적절, try블록의 수행문에서 오류가 발생한 경우에만 실행되기 때문.
	* 수행문1이 예외발생				   // 점유했던 리소스를 해제시키는 수행문;
	   ① -> ③ -> ④			
							} finally {
	   						       점유했던 리소스를 해제시키는 수행문;	<---- 예외발생 여부와 상관없이
													    항상 실행되어야 하는 수행문.
							}

9.다양한 예외처리 방법
	: 코드를 짤 때는 여러가지 방법으로 예외처리를 한다. 자세한 방법은 소스코드 ex2 에 들어가서 확인해보자.